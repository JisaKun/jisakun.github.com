---
layout: post
title: "Q240 Search a 2D Matrix II "
date: 2015-08-08
tags: Divide_And_Conquer Binary_Search
categories: Leetcode
published: true

---
#### Problem Link:[Search a 2D Matrix II ](https://leetcode.com/problems/search-a-2d-matrix-ii/) 

#### Solution 1 Divide and Conquer

##### Idea:

Take care of edges. 

##### Time Complexity:

O(nlog(n))

##### Space Complexity:

O(1)

##### Source code:
{% highlight C++ %}
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
        return helper(matrix, target, pair<int, int> (0, 0), pair<int, int> (matrix.size() - 1, matrix[0].size() - 1));
    }
    
    bool helper(vector<vector<int>>& matrix, int target, pair<int, int> A, pair<int, int> B){
        if (target == matrix[A.first][A.second] || target == matrix[B.first][B.second] ) 
            return true;
        if (target < matrix[A.first][A.second] || target > matrix[B.first][B.second] || (A.first == B.first && A.second == B.second)) 
            return false;
        int m = A.first + ((B.first - A.first) >> 1), n = A.second + ((B.second - A.second) >> 1);
        if (m == A.first && A.second == n)
            return target == matrix[B.first][A.second] || target == matrix[A.first][B.second];
        if ((target >= matrix[m][n] && helper(matrix, target, pair<int, int> (m, n), B)) || (target < matrix[m][n] && helper(matrix, target, A, pair<int, int> (m, n))))
            return true;
        return ((m != A.first || n != B.second) && helper(matrix, target, pair<int, int> (m, A.second), pair<int, int> (B.first, n))) || ((m != B.first || n != A.second) && helper(matrix, target, pair<int, int> (A.first, n), pair<int, int> (m, B.second)));
    }
};

{% endhighlight %}

_TBA_

#### Solution 2 

##### Idea:

Check the code.

##### Time Complexity:

O(n)

##### Space Complexity:

O(1)

##### Source code:
{% highlight C++ %}


{% endhighlight %}