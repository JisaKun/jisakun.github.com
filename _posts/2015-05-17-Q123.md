---
layout: post
title: "Q123 Best Time to Buy and Sell Stock III"
date: 2015-05-17
tags: Array Dynamic_Programming
categories: Leetcode
published: true

---
### Problem Link:[Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) 

### Solution 1 Iteration

#### Idea:
 
Due to the constraint of at most two transactions, there must be a middle point, on the left of which is one transaction and on the right of which is another transaction. So, just iterate all those possible middle point and find the one when the sum of left transaction and right transaction reaches its maximum. 

Tips:   

* In order to avoid TLE, use the relationship among prices[i], prices[i - 1] and prices[i + 1] to speed calculation.    
* the `int oneSell()` function is copied from Q121 without any change.

#### Time Complexity:

O(n^2)

#### Space Complexity:

O(1)

#### Source code:

{% highlight C++ %}

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2) return 0;
        int n = prices.size(), maxPro = 0, left = 0, right = oneSell(vector<int> (prices.begin() + 2, prices.end()));
        for (int i = 1; i < n; i++){
            if (i > 0 && prices[i] > prices[i - 1])
                left = oneSell(vector<int> (prices.begin(), prices.begin() + i + 1));
            if (i < n - 1 && prices[i] < prices[i + 1])
                right = oneSell(vector<int> (prices.begin() + i + 1, prices.end()));
            maxPro = max(maxPro, left + right);
        }
        return maxPro;
    }
    
    int oneSell(vector<int> prices) {
        if (prices.size() < 2) return 0;
        int maxP = 0, minP = prices[0];
        for (int i = 1; i < prices.size(); i++){
            minP = min(minP, prices[i]);
            maxP = max(maxP, prices[i] - minP);
        }
        return maxP;
    }
};


{% endhighlight %}

---
